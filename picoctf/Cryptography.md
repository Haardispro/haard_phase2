# RSA Oracle 

Description: 

Can you abuse the oracle?An attacker was able to intercept communications between a bank and a fintech company. They managed to get the [message](https://artifacts.picoctf.net/c_titan/32/secret.enc) (ciphertext) and the [password](https://artifacts.picoctf.net/c_titan/32/password.enc) that was used to encrypt the message.

Contents of password.enc: 
```
1765037049764047724348114634473658734830490852066061345686916365658618194981097216750929421734812911680434647401939068526285652985802740837961814227312100
```

Contents of secret.enc: 
```
Q�t*$�Wqt�w^Q% 
```


So, this is how the Chosen Plaintext Attack can work to exploit this 

password = t^e mod n 



Ca = 49^e mod n 
Cb = Ca * C

Decrypt: Cb 
hex output: 

int(hex output) // 49 -> convert back to hex and then to ascii   

`openssl enc -aes-256-cbc -d -in secret.enc -k  881d9`

Reference: 
https://crypto.stackexchange.com/questions/2323/how-does-a-chosen-plaintext-attack-on-rsa-work


---
# Custom Encryption 

Contents of `custom_encryption.py`
```python
from random import randint
import sys


def generator(g, x, p):
    return pow(g, x) % p


def encrypt(plaintext, key):
    cipher = []
    for char in plaintext:
        cipher.append(((ord(char) * key*311)))
    return cipher


def is_prime(p):
    v = 0
    for i in range(2, p + 1):
        if p % i == 0:
            v = v + 1
    if v > 1:
        return False
    else:
        return True


def dynamic_xor_encrypt(plaintext, text_key):
    cipher_text = ""
    key_length = len(text_key)
    for i, char in enumerate(plaintext[::-1]):
        key_char = text_key[i % key_length]
        encrypted_char = chr(ord(char) ^ ord(key_char))
        cipher_text += encrypted_char
    return cipher_text


def test(plain_text, text_key):
    p = 97
    g = 31
    if not is_prime(p) and not is_prime(g):
        print("Enter prime numbers")
        return
    a = randint(p-10, p)
    b = randint(g-10, g)
    print(f"a = {a}")
    print(f"b = {b}")
    u = generator(g, a, p)
    v = generator(g, b, p)
    key = generator(v, a, p)
    b_key = generator(u, b, p)
    shared_key = None
    if key == b_key:
        shared_key = key
    else:
        print("Invalid key")
        return
    semi_cipher = dynamic_xor_encrypt(plain_text, text_key)
    cipher = encrypt(semi_cipher, shared_key)
    print(f'cipher is: {cipher}')


if __name__ == "__main__":
    message = sys.argv[1]
    test(message, "trudeau")
```

Contents of `enc_flag`:
```text
a = 95
b = 21
cipher is: [237915, 1850450, 1850450, 158610, 2458455, 2273410, 1744710, 1744710, 1797580, 1110270, 0, 2194105, 555135, 132175, 1797580, 0, 581570, 2273410, 26435, 1638970, 634440, 713745, 158610, 158610, 449395, 158610, 687310, 1348185, 845920, 1295315, 687310, 185045, 317220, 449395]
```

This is what's happening in the given program: 
- A message is taken as an input as an argument 
- First of all, a key is generated by the following algorithm.
  ```
  -> two random numbers(a and b) are generated within a range (p-10, p)
  -> p, q are two random prime numbers are known. 
  -> here, a, b are given in the enc_flag file, so we can calculate the output of the generator function 
  -> the generator function takes in 3 values, g, x(a/b) and p and returns g^x mod p. 
  -> p = 97, g = 31
	u = generator(g, a, p) = 31^95 % 97 = 72
    v = generator(g, b, p) = 31^21 % 97 = 8
    key = generator(v, a, p) = 8^95 % 97 = 85
    b_key = generator(u, b, p) = 72^21 % 97 = 85
    
    as we can see, key == b_key
    therefore, shared_key is assigned the value of 85 now. 
  ```
- After the key is generated the plain_text is ran through an XOR cipher, where the plain_text is XORed with the text_key "trudeau". 
- after that, the XORed string is passed through the function `encrypt`, which takes each character of the string and multiplies its ascii value with the shared_key = 85 and 311. 
- Finally a list of numbers will be generated which will be the encrypted values.

#### Reversing the encryption

- In order to reverse the encryption, firstly I had to divide each number by the shared_key and 311.
- After dividing the numbers, I have to now convert them back to ASCII 
- One of the properties of XOR is that if you XOR a value twice, it returns the original value. 
- After I get the ASCII value, I can XOR it with "trudeau" to get the original string, which is the flag

The below mentioned script implements the above mentioned points. 

Contents of solve.py: 
```python
# shared key = 85 
# text key = trudeau 


x = [237915, 1850450, 1850450, 158610, 2458455, 2273410, 1744710, 1744710, 1797580, 1110270, 0, 2194105, 555135, 132175, 1797580, 0, 581570, 2273410, 26435, 1638970, 634440, 713745, 158610, 158610, 449395, 158610, 687310, 1348185, 845920, 1295315, 687310, 185045, 317220, 449395]

xor_text = []
xor_ascii_number = []
xor_ascii_bin = []

div = 26435 # 85 * 311
for i in range(len(x)):
    y = chr(int(x[i]/div))
    xor_ascii_number.append(int(x[i]/div))
    xor_text.append(y)


print(xor_text)
print(xor_ascii_number)

semi_ciphertext = "".join(xor_text)


plaintext = ""
text_key = "trudeau"
key_length = len(text_key)
for i, char in enumerate(semi_ciphertext):
    key_char = text_key[i % key_length]
    decrypted_char = chr(ord(char) ^ ord(key_char))
    plaintext += decrypted_char
print(plaintext[::-1])
```

flag: `picoCTF{custom_d2cr0pt6d_66778b34}`

---
# miniRSA 

Description:
Let's decrypt this: [ciphertext](https://jupiter.challenges.picoctf.org/static/ee7e2388b45f521b285334abb5a63771/ciphertext)? Something seems a bit small.

Ciphertext: 

```text
N: 29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673
e: 3

ciphertext (c): 2205316413931134031074603746928247799030155221252519872649649212867614751848436763801274360463406171277838056821437115883619169702963504606017565783537203207707757768473109845162808575425972525116337319108047893250549462147185741761825125 
```

This is how the Cipher text C is calculated: 

##### Key generation

The keys for the RSA algorithm are generated in the following way:

1. Choose two large [prime numbers](https://en.wikipedia.org/wiki/Prime_number "Prime number") p and q.
    - To make factoring infeasible, p and q must be chosen at random from a large space of possibilities, such as all prime numbers between 21023 and 21024 (corresponding to a 2,048-bit key). Many different algorithms for prime selection are used in practice.[[29]](https://en.wikipedia.org/wiki/RSA_cryptosystem#cite_note-svenda2016mkq-29)
    - p and q are kept secret.
2. Compute _n_ = _pq_.
    - n is used as the [modulus](https://en.wikipedia.org/wiki/Modular_arithmetic "Modular arithmetic") for both the public and private keys. Its length, usually expressed in bits, is the [key length](https://en.wikipedia.org/wiki/Key_length "Key length").
    - n is released as part of the public key.
3. Compute _λ_(_n_), where λ is [Carmichael's totient function](https://en.wikipedia.org/wiki/Carmichael%27s_totient_function "Carmichael's totient function"). Since _n_ = _pq_, _λ_(_n_) = [lcm](https://en.wikipedia.org/wiki/Least_common_multiple "Least common multiple")(_λ_(_p_), _λ_(_q_)), and since p and q are prime, _λ_(_p_) = _[φ](https://en.wikipedia.org/wiki/Euler_totient_function "Euler totient function")_(_p_) = _p_ − 1, and likewise _λ_(_q_) = _q_ − 1. Hence _λ_(_n_) = lcm(_p_ − 1, _q_ − 1).
    - The lcm may be calculated through the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm "Euclidean algorithm"), since lcm(_a_, _b_) = ⁠|_ab_|/gcd(_a_, _b_)⁠.
    - _λ_(_n_) is kept secret.
4. Choose an integer e such that 1 < _e_ < _λ_(_n_) and [gcd](https://en.wikipedia.org/wiki/Greatest_common_divisor "Greatest common divisor")(_e_, _λ_(_n_)) = 1; that is, e and _λ_(_n_) are [coprime](https://en.wikipedia.org/wiki/Coprime "Coprime").
    - e having a short [bit-length](https://en.wikipedia.org/wiki/Bit-length "Bit-length") and small [Hamming weight](https://en.wikipedia.org/wiki/Hamming_weight "Hamming weight") results in more efficient encryption – the most commonly chosen value for e is 2^16 + 1 = 65537. The smallest (and fastest) possible value for e is 3, but such a small value for e may expose vulnerabilities in insecure padding schemes.   - e is released as part of the public key.
5. Determine d as _d_ ≡ _e_−1 (mod _λ_(_n_)); that is, d is the [modular multiplicative inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse "Modular multiplicative inverse") of e modulo _λ_(_n_).
    - This means: solve for d the equation _de_ ≡ 1 (mod _λ_(_n_)); d can be computed efficiently by using the [extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm "Extended Euclidean algorithm"), since, thanks to e and _λ_(_n_) being coprime, said equation is a form of [Bézout's identity](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity "Bézout's identity"), where d is one of the coefficients.
    - d is kept secret as the _private key exponent_.

The _public key_ consists of the modulus n and the public exponent e. The _private key_ consists of the private exponent d, which must be kept secret. p, q, and _λ_(_n_) must also be kept secret because they can be used to calculate d. In fact, they can all be discarded after d has been computed.

In my given `ciphertext`, e is taken as 3 which is very small and vulnerable to attacks. 

If e is very small, can be easily exploited using Cube Root Attack. 

#### Cube Root Attack: 


We know that 

```
C = p^e mod N 
```

where, 
- C -> Cipher text
- N -> modulus public key 
- e -> exponent, public key 
- p -> original text

Here, if p and e are so small that `p^e < n`, then plain text p can be retrieved simply calculated by the e-th root of c: 

```
p = c^(1/e) (if p^e < N)
```

Such type of simple attacks can be carried out by automated tools like dcode.fr and thats how I got my flag. The flag can also be obtained through a python script, but this is easier.  


![](assets/minirsa.png)


flag: `picoCTF{n33d_a_lArg3r_e_606ce004}`