# RSA Oracle 

Description: 

Can you abuse the oracle?An attacker was able to intercept communications between a bank and a fintech company. They managed to get the [message](https://artifacts.picoctf.net/c_titan/32/secret.enc) (ciphertext) and the [password](https://artifacts.picoctf.net/c_titan/32/password.enc) that was used to encrypt the message.

Contents of password.enc: 
```
1765037049764047724348114634473658734830490852066061345686916365658618194981097216750929421734812911680434647401939068526285652985802740837961814227312100
```

Contents of secret.enc: 
```
Q�t*$�Wqt�w^Q% 
```


So, this is how the Chosen Plaintext Attack can work to exploit this 

password = t^e mod n 



Ca = 49^e mod n 
Cb = Ca * C

Decrypt: Cb 
hex output: 

int(hex output) // 49 -> convert back to hex and then to ascii   

`openssl enc -aes-256-cbc -d -in secret.enc -k  881d9`

Reference: 
https://crypto.stackexchange.com/questions/2323/how-does-a-chosen-plaintext-attack-on-rsa-work


---
# Custom Encryption 

Contents of `custom_encryption.py`
```python
from random import randint
import sys


def generator(g, x, p):
    return pow(g, x) % p


def encrypt(plaintext, key):
    cipher = []
    for char in plaintext:
        cipher.append(((ord(char) * key*311)))
    return cipher


def is_prime(p):
    v = 0
    for i in range(2, p + 1):
        if p % i == 0:
            v = v + 1
    if v > 1:
        return False
    else:
        return True


def dynamic_xor_encrypt(plaintext, text_key):
    cipher_text = ""
    key_length = len(text_key)
    for i, char in enumerate(plaintext[::-1]):
        key_char = text_key[i % key_length]
        encrypted_char = chr(ord(char) ^ ord(key_char))
        cipher_text += encrypted_char
    return cipher_text


def test(plain_text, text_key):
    p = 97
    g = 31
    if not is_prime(p) and not is_prime(g):
        print("Enter prime numbers")
        return
    a = randint(p-10, p)
    b = randint(g-10, g)
    print(f"a = {a}")
    print(f"b = {b}")
    u = generator(g, a, p)
    v = generator(g, b, p)
    key = generator(v, a, p)
    b_key = generator(u, b, p)
    shared_key = None
    if key == b_key:
        shared_key = key
    else:
        print("Invalid key")
        return
    semi_cipher = dynamic_xor_encrypt(plain_text, text_key)
    cipher = encrypt(semi_cipher, shared_key)
    print(f'cipher is: {cipher}')


if __name__ == "__main__":
    message = sys.argv[1]
    test(message, "trudeau")
```

Contents of `enc_flag`:
```text
a = 95
b = 21
cipher is: [237915, 1850450, 1850450, 158610, 2458455, 2273410, 1744710, 1744710, 1797580, 1110270, 0, 2194105, 555135, 132175, 1797580, 0, 581570, 2273410, 26435, 1638970, 634440, 713745, 158610, 158610, 449395, 158610, 687310, 1348185, 845920, 1295315, 687310, 185045, 317220, 449395]
```

This is what's happening in the given program: 
- A message is taken as an input as an argument 
- First of all, a key is generated by the following algorithm.
  ```
  -> two random numbers(a and b) are generated within a range (p-10, p)
  -> p, q are two random prime numbers are known. 
  -> here, a, b are given in the enc_flag file, so we can calculate the output of the generator function 
  -> the generator function takes in 3 values, g, x(a/b) and p and returns g^x mod p. 
  -> p = 97, g = 31
	u = generator(g, a, p) = 31^95 % 97 = 72
    v = generator(g, b, p) = 31^21 % 97 = 8
    key = generator(v, a, p) = 8^95 % 97 = 85
    b_key = generator(u, b, p) = 72^21 % 97 = 85
    
    as we can see, key == b_key
    therefore, shared_key is assigned the value of 85 now. 
  ```
- After the key is generated the plain_text is ran through an XOR cipher, where the plain_text is XORed with the text_key "trudeau". 
- after that, the XORed string is passed through the function `encrypt`, which takes each character of the string and multiplies its ascii value with the shared_key = 85 and 311. 
- Finally a list of numbers will be generated which will be the encrypted values.

#### Reversing the encryption

- In order to reverse the encryption, firstly I had to divide each number by the shared_key and 311.
- After dividing the numbers, I have to now convert them back to ASCII 
- One of the properties of XOR is that if you XOR a value twice, it returns the original value. 
- After I get the ASCII value, I can XOR it with "trudeau" to get the original string, which is the flag

The below mentioned script implements the above mentioned points. 

Contents of solve.py: 
```python
# shared key = 85 
# text key = trudeau 


x = [237915, 1850450, 1850450, 158610, 2458455, 2273410, 1744710, 1744710, 1797580, 1110270, 0, 2194105, 555135, 132175, 1797580, 0, 581570, 2273410, 26435, 1638970, 634440, 713745, 158610, 158610, 449395, 158610, 687310, 1348185, 845920, 1295315, 687310, 185045, 317220, 449395]

xor_text = []
xor_ascii_number = []
xor_ascii_bin = []

div = 26435 # 85 * 311
for i in range(len(x)):
    y = chr(int(x[i]/div))
    xor_ascii_number.append(int(x[i]/div))
    xor_text.append(y)


print(xor_text)
print(xor_ascii_number)

semi_ciphertext = "".join(xor_text)


plaintext = ""
text_key = "trudeau"
key_length = len(text_key)
for i, char in enumerate(semi_ciphertext):
    key_char = text_key[i % key_length]
    decrypted_char = chr(ord(char) ^ ord(key_char))
    plaintext += decrypted_char
print(plaintext[::-1])
```

flag: `picoCTF{custom_d2cr0pt6d_66778b34}`

---
# miniRSA 

read about RSA cryptosystem and how it works 

N, e and C were given. 

e is very small, can be easily exploited using Cube Root Attack. 

put into dcode.fr to get the flag. 


